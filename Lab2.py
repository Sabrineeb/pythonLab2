# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sbwngcY6HLyXqIH9w0ZF_433NuF1x4mH

**FastAPI app with PostgreSQL Tutorial**

First thing, create a virtual environment and activate it:
"""

!python -m venv myenv
!source myenv/bin/activate

"""Pour créer un environnement virtuel en Python, on utilise cette commande :
python -m venv myenv

Ensuite, pour l’activer :

Sur Linux ou macOS, tape :
source myenv/bin/activate

Sur Windows, tape :
myenv\Scripts\activate

Il ne faut pas mettre ! devant ces commandes, sauf si tu es dans un notebook Jupyter. Sinon, utilise-les directement dans un terminal.

Install all the dependencies needed for this application:
"""

!pip install fastapi sqlalchemy psycopg2-binary uvicorn

"""**Start FastAPI Application**

Create a main.py file:
"""

from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Annotated

app = FastAPI()

"""Let’s create two pydantic base models:"""

class ChoiceBase(BaseModel):
    choice_text: str
    is_correct: bool

class QuestionBase(BaseModel):
    question_text: str
    choices: List[ChoiceBase]

"""**Create PostgreSQL connection**

create our data models:
"""

# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# URL string for the Postgres database
# In this example, the database name is 'quizApp'
URL_DATABASE = 'postgresql://USERNAME:PASSWD@localhost:5432/quizApp'

engine = create_engine(URL_DATABASE)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

"""**Create PostgreSQL Tables**

Create models.py:
"""

from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

with open("database.py", "w") as f:
    f.write("from sqlalchemy.ext.declarative import declarative_base\nBase = declarative_base()")

"""L’erreur `ModuleNotFoundError: No module named 'database'` signifie que Python ne trouve pas le module nommé `database` que tu essaies d’importer. Pour résoudre cela, il faut créer un fichier nommé `database.py` dans le même dossier que ton script. Ce fichier doit contenir la ligne suivante : `Base = declarative_base()` après avoir importé `declarative_base` depuis SQLAlchemy. Cela permet de définir la base commune à toutes les classes de modèles SQLAlchemy que tu vas créer, comme `Questions` et `Choices`.

Now go back to our main.py file and import the following:
"""

from sqlalchemy import Boolean, Column, ForeignKey, Integer, String
from database import Base

class Questions(Base):
    __tablename__ = 'questions'
    id = Column(Integer, primary_key=True, index=True)
    question_text = Column(String, index=True)

class Choices(Base):
    __tablename__ = 'choices'
    id = Column(Integer, primary_key=True, index=True)
    choice_text = Column(String, index=True)
    is_correct = Column(Boolean, default=False)
    question_id = Column(Integer, ForeignKey("questions.id"))

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

"""L’erreur `ModuleNotFoundError: No module named 'models'` signifie que Python ne trouve pas le fichier nommé `models.py` dans ton projet. Ce fichier est nécessaire car il contient les définitions des classes et des tables que tu veux utiliser avec SQLAlchemy. De même, si tu importes `from database import engine`, Python a besoin d’un fichier `database.py` dans le même dossier contenant la configuration de la base de données. Pour corriger cette erreur, il faut s’assurer que les fichiers `models.py` et `database.py` existent bien dans le répertoire de ton projet, et qu’ils sont correctement remplis avec les classes et les objets nécessaires (comme `Base`, `engine`, etc.).

then under app = FastAPI(), add the following:
"""

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"  # ou une URL PostgreSQL/MySQL

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

class Questions(Base):
    __tablename__ = 'questions'
    __table_args__ = {'extend_existing': True}

    id = Column(Integer, primary_key=True, index=True)
    question_text = Column(String, index=True)

"""L’erreur rencontrée indique que la table `questions` a déjà été définie une première fois dans le même environnement Python, souvent à cause d’une exécution répétée dans un notebook sans redémarrage du noyau. SQLAlchemy empêche cette redéfinition automatique pour éviter des conflits ou des incohérences dans la structure de la base de données. Pour corriger cela, il est recommandé de redémarrer l’environnement (kernel ou runtime), ce qui réinitialise la mémoire et élimine les anciennes définitions. Alternativement, on peut ajouter `__table_args__ = {'extend_existing': True}` à la classe pour autoriser explicitement la redéfinition, mais cette pratique doit être utilisée avec précaution.

**Connect FastAPI, PostgreSQL with SQLAlchemy**
"""

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

"""Then create this important annotation after the get_db() method:"""

!source myenv/bin/activate
!pip install ipykernel

!python -m ipykernel install --user --name=myenv --display-name="Python (myenv)"

"""L'erreur "ModuleNotFoundError: No module named 'fastapi'" signifie que le module 'fastapi' n'est pas installé dans l'environnement Python utilisé par votre notebook Jupyter. Vous avez probablement créé un environnement virtuel ('myenv') et installé 'fastapi' à l'intérieur, mais le noyau Jupyter actuel ne s'exécute pas dans cet environnement. Pour résoudre ce problème, vous devez installer le package 'ipykernel' dans votre environnement virtuel, puis ajouter l'environnement à la liste des noyaux de Jupyter avec la commande 'python -m ipykernel install --user --name=myenv --display-name="Python (myenv)"'. Enfin, redémarrez le noyau Jupyter (ou démarrez-en un nouveau) et sélectionnez "Python (myenv)" comme noyau pour exécuter votre code dans l'environnement virtuel où 'fastapi' est installé.

FastAPI Add Question Endpoint

Now let’s create our API endpoints. We will create the add question endpoint, at the end of main.py add the following:
"""

!source myenv/bin/activate

!pip install ipykernel

!python -m ipykernel install --user --name=myenv --display-name="Python (myenv)"

"""L'erreur "ModuleNotFoundError: No module named 'fastapi'" signifie que la bibliothèque fastapi n'est pas installée dans l'environnement Python que votre notebook Jupyter utilise. Même si vous l'avez installée dans votre environnement virtuel myenv, Jupyter doit être configuré pour utiliser cet environnement. Pour cela, il faut : 1) activer l'environnement virtuel ; 2) installer ipykernel dans cet environnement ; 3) enregistrer l'environnement comme un noyau Jupyter ; et 4) redémarrer le noyau du notebook et sélectionner le nouveau noyau "Python (myenv)". Ces étapes garantissent que votre notebook s'exécute dans l'environnement où fastapi est disponible

Let’s run our application:
"""

!uvicorn main:app --reload

"""Test your API endpoint in FastAPI Swagger with the following data:"""

{
  "question_text": "What is the best Python Framework",
  "choices": [
    {
      "choice_text": "FastAPI",
      "is_correct": True # Changed true to True
    },
    {
      "choice_text": "Flask",
      "is_correct": False # Changed false to False
    },
    {
      "choice_text": "Django",
      "is_correct": False # Changed false to False
    }
  ]
}

"""L'erreur NameError: name 'true' is not defined survient car le code utilise true au lieu de True pour représenter une valeur booléenne vraie. En Python, les valeurs booléennes sont exprimées par les mots-clés True et False, avec une majuscule initiale. Le code essaie d'utiliser une variable appelée true qui n'a pas été définie, d'où l'erreur. La correction consiste à remplacer true par True et false par False dans le code pour utiliser les mots-clés booléens corrects.

**Other FastAPI Endpoints**

Let’s add a Get request method to be able to fetch a question:
"""

!source myenv/bin/activate

!pip install ipykernel

!python -m ipykernel install --user --name=myenv --display-name="Python (myenv)"

"""L'erreur ModuleNotFoundError: No module named 'fastapi' survient car la librairie fastapi n'est pas installée dans l'environnement Python utilisé par votre notebook Jupyter. Même si vous l'avez installée dans un environnement virtuel nommé myenv, Jupyter doit être configuré pour utiliser cet environnement. La solution consiste à : 1) activer l'environnement virtuel myenv ; 2) installer ipykernel dans cet environnement ; 3) ajouter l'environnement à la liste des noyaux Jupyter ; et 4) redémarrer le noyau du notebook et sélectionner le nouveau noyau "Python (myenv)". Ces étapes garantissent que votre notebook s'exécute dans l'environnement où fastapi est disponible, résolvant ainsi l'erreur.

Let’s add a Get request method to be able to fetch a question choices:
"""

!pip install fastapi[all]

# models.py
from sqlalchemy import Boolean, Column, ForeignKey, Integer, String
from database import Base  # Assuming you have a database.py file with Base defined

class Questions(Base):
    __tablename__ = 'questions'
    __table_args__ = {'extend_existing': True} # Add this line
    id = Column(Integer, primary_key=True, index=True)
    question_text = Column(String, index=True)

class Choices(Base):
    __tablename__ = 'choices'
    __table_args__ = {'extend_existing': True} # Add this line
    id = Column(Integer, primary_key=True, index=True)
    choice_text = Column(String, index=True)
    is_correct = Column(Boolean, default=False)
    question_id = Column(Integer, ForeignKey("questions.id"))

"""L'erreur "InvalidRequestError: Table 'questions' is already defined for this MetaData instance" survient parce que vous essayez de redéfinir la table Questions dans votre code, probablement dans un notebook Jupyter où les définitions persistent entre les exécutions de cellules. SQLAlchemy empêche cette redéfinition pour éviter les conflits et les incohérences dans la structure de la base de données. La solution consiste à ajouter __table_args__ = {'extend_existing': True} à la définition de la classe Questions (et Choices si elle est également redéfinie). Cela indique à SQLAlchemy d'étendre la table existante au lieu de la redéfinir, ce qui résout l'erreur. Une alternative, souvent plus propre, est de redémarrer le noyau Jupyter pour effacer les définitions précédentes et commencer avec un environnement vierge. N'oubliez pas que extend_existing peut ne pas être adapté si vous modifiez intentionnellement la structure des tables ; dans ce cas, il est préférable de recréer la base de données ou d'utiliser des commandes SQL pour modifier les tables existantes."""